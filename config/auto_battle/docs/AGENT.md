# OneDragon ZZZ 脚本速成指南

#----------------------------------------------------------------------
# 1. 操作 (Operations)
# `operations` 是所有动作的基础，它是一个包含多个原子操作的列表，会按顺序执行。
#----------------------------------------------------------------------

## 1.1 操作的语法

### 基础操作：`op_name`
`op_name` 定义了要执行的按键操作。

**可用 `op_name` 列表:**
```
  战斗相关: 按键-闪避, 按键-普通攻击, 按键-特殊攻击, 按键-终结技, 按键-快速支援
  角色切换: 按键-切换角色-下一个, 按键-切换角色-上一个, 按键-切换角色 (需 agent_name 参数)
  连携技:   按键-连携技-左, 按键-连携技-右, 按键-连携技-取消
  移动:     按键-移动-前, 按键-移动-后, 按键-移动-左, 按键-移动-右
  其他:     按键-锁定敌人
```

### 操作变体 (点击, 按下, 松开)
每个按键都支持三种模式：

**1. 点击 (默认)**
执行一次快速的按下和松开。
```yaml
operations:
  - op_name: "按键-普通攻击"
```

**2. 按下**
只执行“按下”动作，通常用于长按。
```yaml
operations:
  - op_name: "按键-特殊攻击-按下"
```

**3. 松开**
只执行“松开”动作，用于结束长按或防止按键卡住。
```yaml
operations:
  - op_name: "按键-特殊攻击-松开"
```

## 1.2 如何编写连贯的操作 (连招)

通过组合操作和使用参数，可以编写出连贯的连招。

**核心参数:**
- `repeat`: 重复执行同一操作的次数。
- `post_delay`: 在操作执行**后**等待的秒数。此参数不支持在长按操作中用于定义按住时间！禁止接在长按后面。
- `op_name: "等待秒数"`: 在两个操作之间插入明确的停顿。

**重要规则:** 绝区零游戏引擎目前只接受0.1秒以上的按键间隔。因此，在连续操作之间，必须使用 `post_delay` 或 `等待秒数` 来确保每个动作之间至少有0.1秒的间隔。

**示例 1: "普攻x2 -> 停0.5秒 -> 特殊攻击"**
```yaml
operations:
  - op_name: "按键-普通攻击"
    repeat: 2
    post_delay: 0.1
  - op_name: "等待秒数"
    seconds: 0.5
  - op_name: "按键-特殊攻击"
```

**示例 2: 长按特殊攻击1.2秒**
```yaml
operations:
  - op_name: "按键-特殊攻击-按下" # 只执行按下动作
  - op_name: "等待秒数"
    seconds: 1.2
  - op_name: "按键-特殊攻击-松开" # 显式松开按键
```

#----------------------------------------------------------------------
# 2. 状态 (States)
# `states` 是决策的核心，它定义了执行某个 `operations` 列表所需满足的条件。
#----------------------------------------------------------------------

## 2.1 状态语法

**基本格式:** `[状态名, 时间下限, 时间上限]{值下限, 值上限}`

-   **时间窗口**: `[状态名, 时间下限, 时间上限]` 检查状态的触发时间是否在此范围内。
  - 例如 `[状态名, 2, 10]` 表示“状态在过去2到10秒内触发过”。
  - 时间下限为负数时，表示“倒计时”或“未来事件”。例如 `[状态名, -5, -1]` 表示“状态将在未来1到5秒内触发”。
-   **数值范围**: `[能量值, 0, 999]{50, 120}` 表示“能量值在50到120之间”。
-   **数值相等**: `[敌人数量, 0, 999]{3}` 表示“敌人数量等于3”。
-   **逻辑运算**: 使用 `&` (与), `|` (或), `!` (非) 和 `()` 括号来组合复杂逻辑。
    -   示例: `([状态A] | [状态B]) & ![状态C]`

## 2.2 如何设置与清除状态

通过 `设置状态` 和 `清除状态` 操作，可以精准地管理自定义状态，实现脚本不同部分的通信。

### 1. 设置状态 (AtomicSetState)

**推荐格式:**
```yaml
- op_name: "设置状态"
  state: "状态名"              # 设置单个状态
  # state_list: ["状态1", "状态2"] # 或设置多个状态 (与state互斥)
  seconds: 5.0                # 状态持续时间（秒），负数代表倒计时
  seconds_add: 2.0            # 在现有持续时间基础上增加的秒数，负数代表增加倒计时
  value: 100                  # 设置状态的具体值
  add: 50                     # 在现有状态值基础上增加的值
```

### 2. 清除状态 (AtomicClearState)

**推荐格式 (默认使用 `state_list`):**
```yaml
- op_name: "清除状态"
  state_list: ["状态1", "状态2"] # 清除多个状态
```

## 2.3 如何编写状态树 (IF-ELIF-ELSE)

状态树通过 `handlers` 列表构建，它是一个从上到下匹配的 **IF-ELIF-ELSE** 逻辑链。

**处理器结构:**
```yaml
- states: "[条件A] & ![条件C]"      # IF 条件
  debug_name: "简要说明此分支意图"    # 可选：调试日志中显示的名称，例如 "安比-终结技判断"
  interrupt_states: "[紧急条件]"     # 可选：如果此条件发生，则中断 operations
  operations:
    # ... 执行动作 ...
```

**示例: 安比的技能决策树**
```yaml
handlers:
  - states: "[前台-安比]" # 根节点：确保是安比在场
    debug_name: "安比在场时的决策"
    sub_handlers:
      # IF: 能量值大于等于80 且 终结技可用
      - states: "[能量值, 0, 999]{80, 999} & [安比-终结技可用]"
        debug_name: "安比-释放终结技"
        operations:
          - op_name: "按键-终结技"
      # ELIF: 特殊技可用
      - states: "[安比-特殊技可用]"
        debug_name: "安比-释放特殊技"
        operations:
          - op_name: "按键-特殊攻击"
      # ELSE: 默认情况
      - states: ""
        debug_name: "安比-执行普攻"
        operations:
          - op_name: "按键-普通攻击"
```

## 2.4 高阶技巧：使用负数时间实现动态倒计时

### 核心机制
- **设置倒计时**: 使用 `seconds: -N` 设置一个持续 `N` 秒的倒计时。状态的内部时间值从 `-N` 开始，每秒向 `0` 靠近。
- **延长倒计时**: 使用 `seconds_add: -M` 为倒计时**增加** `M` 秒。例如，一个还剩5秒（内部值为-5）的计时器，增加3秒后，将还剩8秒（内部值变为-8）。
- **判断倒计时**: 使用 `[状态名, -N, 0]` 判断一个倒计时是否仍在生效。

### 场景：可刷新的敌人“失衡”计时器

**目标:** 敌人失衡时，获得一个12秒的输出窗口，并且每次攻击可以延长这个窗口1秒。

**步骤 A: 初始化失衡计时器 (12秒)**
```yaml
# 监听敌人失衡事件，并设置一个12秒的倒计时
handlers:
  - states: "[敌人-失衡, 0, 1]"
    operations:
      - op_name: "设置状态"
        state: "自定义-失衡计时"
        seconds: -12 # 关键：设置一个12秒的倒计时
```

**步骤 B: 在连招中延长计时器 (延长1秒)**
```yaml
# 在某个连招的 operations 列表中
- op_name: "按键-普通攻击"
- op_name: "设置状态"
  state: "自定义-失衡计时"
  seconds_add: -1 # 关键：为倒计时增加1秒（内部值-1）
```

**步骤 C: 根据计时器做出决策**
```yaml
# 在此期间执行高伤害连招
handlers:
  # 条件: "失衡计时"正在生效 (即其内部时间为负数)
  # 使用一个很大的负数作为下限，确保无论延长多少次都能正确检测
  - states: "[自定义-失衡计时, -99, 0]"
    operations:
      - operation_template: "强力追击连招"
```

#----------------------------------------------------------------------
# 3. 场景 (Scenes)
# `scenes` 是组织所有决策逻辑的顶层容器。
#----------------------------------------------------------------------

## 3.1 如何构建 Scenes

一个完整的脚本由一个 `scenes` 列表构成。每个 `scene` 都是一个独立的处理单元，包含三个核心部分：

1.  **`triggers` (触发器)**: 一个列表，定义了什么事件会“激活”这个场景。
    -   例如 `["闪避识别-红光", "闪避识别-黄光"]`。
    -   一个空的 `[]` 列表代表这是一个“默认场景”，它总是处于激活状态。

2.  **`priority` (优先级)**: 一个数字，决定了场景的“重要性”。**数字越大，优先级越高**。

3.  **`handlers` (处理器)**: 一个列表，包含了我们在第二部分中学习的状态树。当场景被激活时，其内部的状态树就会被执行。

**构建示例:**
```yaml
scenes:
  # 场景A: 高优先级的闪避场景
  - triggers: ["闪避识别-红光"]
    priority: 99
    handlers:
      # ... 这里放入闪避的状态树 ...
      - states: "[自定义-红光闪避, 0, 1]"
        operations:
          - op_name: "按键-闪避"

  # 场景B: 低优先级的常规攻击场景
  - triggers: [] # 默认激活
    priority: 9
    handlers:
      # ... 这里放入角色的攻击状态树 ...
      - states: "[前台-安比]"
        sub_handlers:
          - ...
```

## 3.2 Scenes 的运作机制：事件驱动与抢占

`Scenes` 的运作方式不是一个简单的“从高到低轮询”循环。它是一个更高效、更复杂的**事件驱动与抢占**模型。

**1. 事件驱动激活 (Event-Driven Activation)**

-   **监听**: 在脚本开始时，每个 `scene` 都会将其 `triggers` 列表中的状态“注册”到系统中，表示它正在“监听”这些状态的变化。
-   **唤醒**: 当游戏中的某个状态（例如 `闪避识别-红光`）被**检测到或更新**时，系统会“唤醒”所有监听了这个状态的 `scene`。
-   **仲裁**: 如果有多个 `scene` 被同时唤醒，只有 `priority` 最高的那个场景会最终被执行。

**2. 执行与抢占式中断 (Execution and Preemptive Interruption)**

这是理解 `scenes` 运作方式最核心、最关键的一点。

-   **进入“执行”状态**: 当一个场景（例如 `priority: 9` 的攻击场景）开始执行其 `operations` 列表时，它就进入了“执行中”的状态。

-   **屏蔽低优先级监听**: 在这个场景“执行中”的整个期间（例如，一个长连招的几秒内），系统会**暂时忽略**所有**等于或低于**当前场景优先级的 `triggers`。在此例中，系统不会再理会任何 `priority <= 9` 的场景的触发事件。

-   **高优先级抢占**: 同时，系统仍然在**持续监听**所有**高于**当前场景优先级的 `triggers`。
    -   如果在 `priority: 9` 的攻击连招执行到一半时，一个 `priority: 99` 的闪避场景的触发器（例如 `闪避识别-红光`）被激活了，那么这个高优先级场景会**立即抢占控制权**。
    -   当前的攻击连招会被**瞬间打断**。
    -   `priority: 99` 的闪避场景会开始执行它的 `handlers`。

-   **恢复**: 当高优先级的场景执行完毕后，系统会恢复到初始状态，重新开始监听所有场景的 `triggers`。

#----------------------------------------------------------------------
# 4. 模板 (Templates)
# 模板是实现脚本模块化和代码复用的核心机制。它允许将复杂的逻辑拆分成易于管理的小文件。
#----------------------------------------------------------------------

## 4.1 模板的层级与引用规则

模板系统在设计上分为三个层级：

1.  **战斗模板 (Battle Template)**
    -   **路径**: `config/auto_battle/*.yml`
    -   **职责**: 顶层策略，定义 `scenes` 和 `priority`，决定在什么时机调用哪个状态模板。

2.  **状态模板 (State Template)**
    -   **路径**: `config/auto_battle_state_handler/*.yml`
    -   **职责**: 中层逻辑层，定义角色的决策树或特定情境（如闪避、连携）的处理逻辑。

3.  **操作模板 (Operation Template)**
    -   **路径**: `config/auto_battle_operation/*.yml`
    -   **职责**: 底层执行层，定义一个具体的、可复用的操作序列（连招）。

**核心引用规则:**
一个模板**只能**引用**同层级或更低层级**的模板。
-   **允许**: 战斗模板 -> 状态模板 -> 操作模板
-   **允许**: 状态模板 -> 状态模板 (例如，一个总模板调用多个子模板)
-   **允许**: 状态模板 -> 操作模板
-   **禁止**: 操作模板 -> 状态模板 (底层不能调用上层逻辑)

## 4.2 语法与用法

**语法:**
-   `state_template: "模板名"`: 用于调用一个状态模板。
-   `operation_template: "模板名"`: 用于调用一个操作模板。
-   在一个 `operations` 列表中直接使用字符串 `"- 模板名"` 是 `operation_template` 的简写。

**用法示例 (三层调用):**

**1. 在“战斗模板”中调用“状态模板”**
```yaml
# 文件: 全配队通用.yml (战斗模板)
scenes:
  - triggers: []
    priority: 9
    handlers:
      - state_template: "速切模板-全角色" # 调用状态模板
```

**2. 在“状态模板”中调用“操作模板”**
```yaml
# 文件: 速切模板-安比.yml (状态模板)
handlers:
  - states: "[安比-特殊技可用]"
    operations:
      - operation_template: "安比-3A普E" # 调用操作模板
```

**3. “操作模板”的最终内容**
```yaml
# 文件: 安比-3A普E.yml (操作模板)
# 注意：每个操作后都必须有不小于0.1秒的延迟
operations:
  - op_name: "按键-普通攻击"
    repeat: 3
    post_delay: 0.1 # 每次点击后延迟0.1秒
  - op_name: "按键-特殊攻击"
    post_delay: 0.1 # 动作结束后延迟0.1秒
```

## 4.3 高阶技巧: 操作模板的嵌套与组装

除了状态模板可以嵌套外，操作模板之间也可以互相调用。这允许你将一个长连招拆分成几个基础部分，然后按需“组装”，极大地提高了连招的可维护性和复用性。

**示例：组装一个“安比”的复杂连招**

**目标**: 创建一个“普攻x3 -> 停顿 -> 特殊攻击”的连招模板。

**步骤 A: 创建基础的操作模板“零件”**

1.  创建一个基础的普攻模板 `安比-三连普攻.yml`：
    ```yaml
    # 文件: 安比-三连普攻.yml (操作模板)
    operations:
      - op_name: "按键-普通攻击"
        repeat: 3
        post_delay: 0.1
    ```
2.  创建一个基础的特殊技收尾模板 `安比-特殊技收尾.yml`：
    ```yaml
    # 文件: 安比-特殊技收尾.yml (操作模板)
    operations:
      - op_name: "按键-特殊攻击"
        post_delay: 0.1
    ```

**步骤 B: 创建“组装”后的操作模板**

现在，创建一个新的操作模板，通过 `operation_template` 来调用上面两个“零件”，将它们组装起来。

```yaml
# 文件: 安比-普攻接特殊.yml (操作模板)
operations:
  # 第一部分：执行三连普攻
  - operation_template: "安比-三连普攻"

  # 第二部分：插入停顿
  - op_name: "等待秒数"
    seconds: 0.2

  # 第三部分：用特殊技收尾
  - operation_template: "安比-特殊技收尾"
```

**步骤 C: 在状态模板中调用**

最终，在角色的状态树中，只需要调用这个组装好的“总成”模板即可。

```yaml
# 文件: 速切模板-安比.yml (状态模板)
handlers:
  - states: "[某些条件]"
    operations:
      - operation_template: "安比-普攻接特殊"
```

#----------------------------------------------------------------------
# 5. 全局参数 (Global Parameters)
# 全局参数是位于主战斗模板文件（如 `全配队通用.yml`）顶层的配置项，它们控制着自动战斗系统的整体行为和各种检测机制。
#----------------------------------------------------------------------

## 5.1 脚本元数据 (Script Metadata)

这些参数提供了关于脚本的基本信息。

-   `author`: 脚本的作者。
-   `thanks`: 对贡献者的致谢。
-   `homepage`: 脚本或项目的主页链接。
-   `version`: 脚本的版本号。
-   `team_list`: (当前为空) 可能用于定义或引用预设的队伍列表。
-   `introduction`: 脚本的主要功能和适用场景简介。

## 5.2 检测与间隔设置 (Detection & Interval Settings)

这些参数定义了系统对各种游戏状态进行检测的频率。

-   `check_dodge_interval`: 闪避识别的检测间隔（秒）。
-   `check_agent_interval`: 代理人（当前操作角色）状态识别的检测间隔（秒）。
-   `check_chain_interval`: 连携技按键可用状态识别的检测间隔（秒）。
-   `check_quick_interval`: 快速支援按键可用状态识别的检测间隔（秒）。
-   `auto_lock_interval`: 自动锁定敌人的检测间隔（秒）。设置为 `-1` 表示不自动锁定。
-   `auto_turn_interval`: 镜头自动转向目标敌人的间隔（秒）。

## 5.3 目标检测相关 (Target Detection Settings)

这些参数专注于对敌人状态的检测。

-   `target_lock_interval`: 目标锁定状态的检测间隔（秒）。
-   `abnormal_status_interval`: 目标异常状态（如眩晕、冻结）的检测间隔（秒）。设置为 `0` 表示不检测。（**注意：此功能目前暂未实现**）

#----------------------------------------------------------------------
# 6. 设计思路：全配队通用 (Design Philosophy: Universal Team Composition)
# “全配队通用”脚本的核心设计思想是**模块化**与**事件驱动分层**。它旨在创建一个高度可扩展的框架，通过将**战略 (何时做)**、**决策 (做什么)** 和 **动作 (如何做)** 分离，来适应任意的角色组合，而无需为每个队伍编写独立的顶层脚本。
#----------------------------------------------------------------------

## 6.1 文件结构与关键文件

这种设计思想体现在一个清晰的三层文件结构中：

```
config/
├── auto_battle/                # 1. 顶层战略 (战斗模板)
│   └── 全配队通用.yml
│
├── auto_battle_state_handler/  # 2. 中层决策 (状态模板)
│   ├── 速切模板-全角色.yml
│   ├── 轮换-救命-全角色.yml
│   ├── 轮换-合轴-全角色.yml
│   └── ... (其他通用机制或角色专属决策)
│
└── auto_battle_operation/      # 3. 底层动作 (操作模板)
    ├── 艾莲-冲刺蓄力攻击.yml
    └── ... (其他角色的原子化动作)
```

**关键文件与概念解析:**

1.  **`全配队通用.yml` (战斗模板 - 事件调度中心)**
    -   **角色**: 整个自动战斗的**唯一入口**和**事件调度器**。
    -   **职责**:
        -   **定义 `scenes`**: 文件的主体由多个 `scene` 构成，每个 `scene` 监听不同的游戏事件（如 `"闪避识别-红光"`, `"前台-血量扣减"`）。
        -   **设置 `priority`**: 为每个事件（`scene`）设定优先级。这是脚本的核心战略，决定了在多个事件同时发生时，优先响应哪一个（例如，`闪避(99)` > `连携(98)` > `挨打(90)`）。
        -   **分派任务**: 在监听到特定事件后，它**不直接处理**，而是调用相应的**状态模板**来执行具体的决策逻辑。

2.  **通用机制类状态模板 (例如 `轮换-救命-全角色.yml`)**
    -   **角色**: **通用游戏机制的处理器**。
    -   **职责**: 这些模板封装了与具体角色无关、但对所有角色都适用的逻辑。它们是实现“全配队通用”的关键。`全配队通用.yml` 中提到的关键通用模板包括：
        -   `支援攻击模板-*`: 处理黄光/格挡时的支援攻击逻辑。
        -   `轮换-救命-全角色`: 处理低血量时的保命逻辑（如切人开大）。
        -   `轮换-合轴-全角色`: 处理合轴时，为了补增益而换人的逻辑。
        -   `轮换-紧急-全角色`: 在一套动作打完后，判断是否需要立即换人。
        -   `连携模板-通用`: 处理连携技的通用逻辑。

3.  **角色专属类状态模板 (`速切模板-安比.yml`)**
    -   **角色**: 单个角色的**“大脑”**。
    -   **职责**: 包含某个特定角色的常规站场输出决策逻辑。它会在“主线程”场景中，由一个“路由器”模板（`速切模板-全角色.yml`）根据当前在场角色进行调用。

4.  **操作模板 (`艾莲-冲刺蓄力攻击.yml`)**
    -   **角色**: 角色的**“手和脚”**，一个可复用的原子化连招。
    -   **职责**: 包含执行一个具体动作所需的原始按键和延迟序列。

**总结**: 这种设计的精髓在于，`全配队通用.yml` 只负责**“监听事件”和“设定优先级”**，然后像一个项目经理一样，将具体任务**分派**给不同的“专家”（各种状态模板）去处理。这使得添加新角色或修改某个通用逻辑（如闪避策略）时，只需要修改对应的状态/操作模板，而无需触动顶层的战略框架。
## 6.2 核心设计：状态引用树与模块化思想 (最终深度修正版)

“全配队通用”设计的精髓，是其**事件驱动的优先级调度**与**高度解耦的状态模板引用**相结合。顶层战略文件 `全配队通用.yml` 像一个“任务调度中心”，它根据不同事件的优先级，将任务分派给不同的“专家状态模板”处理。

以下是根据代码真实分析得出的、包含所有关键通用模板的**状态引用树**：

```
【顶层战略: 全配队通用】
     │
     ├─ scene: [闪避事件] (priority: 99)
     │   ├─ state_template: "支援攻击模板-*" (处理黄光/格挡的专家系列)
     │   └─ state_template: "闪A模板-全角色" (处理红光/声音闪避的专家)
     │
     ├─ scene: [连携事件] (priority: 98)
     │   └─ state_template: "连携模板-通用"
     │
     ├─ scene: [快速支援事件] (priority: 97)
     │   └─ state_template: "快速支援模板-全角色"
     │
     ├─ scene: [受击事件] (priority: 90)
     │   ├─ state_template: "轮换-救命-全角色" (保命专家)
     │   └─ state_template: "闪A模板-全角色" (受击后闪避反击)
     │
     ├─ scene: [连招结束事件] (priority: 80)
     │   └─ state_template: "轮换-合轴-全角色" (合轴/补Buff专家)
     │
     └─ scene: [默认循环] (priority: 9)
         ├─ state_template: "站场模板-未识别角色" (前置检查)
         ├─ state_template: "自动锁定模板" (前置检查)
         ├─ state_template: "轮换-紧急-全角色" (前置检查)
         │
         └─ state_template: "速切模板-全角色" (角色分派器)
             └─ ... (最终分派到具体角色模板)
```

**关键状态模板用意解析:**

1.  **`全配队通用.yml` (根节点 - 战略层)**
    -   **用意**: 作为**事件调度中心**。它定义了各种事件（`scenes`）的优先级，并根据触发的事件，将任务分派给对应的“专家”。

2.  **`支援攻击模板-*` 系列 & `闪A模板-全角色` (防御反击专家)**
    -   **用意**: 在最高优的`[闪避事件]`中被调用，分别处理“黄光格挡”和“红光闪A”这两种核心防御机制。

3.  **`连携模板-通用` & `快速支援模板-全角色` (进攻机会专家)**
    -   **用意**: 分别处理“连携技”和“快速支援”这两个稍纵即逝的进攻机会。它们被放在高优先级，以确保能及时响应。

4.  **`轮换-救命-全角色` (保命专家)**
    -   **用意**: 作为“安全气囊”。当在场角色受击时被触发，并寻找队伍里是否有拥有终结技的队友，然后执行切人开大来保命。

5.  **`轮换-合轴-全角色` (合轴/轮换专家)**
    -   **用意**: 在一套动作打完后（由`自定义-合轴时间`触发），由该模板判断是否需要为了补增益、或为了让另一个核心角色上场而进行“合轴”换人。

6.  **`站场模板-未识别角色` / `自动锁定模板` / `轮换-紧急-全角色` (主循环前置检查)**
    -   **用意**: 在最低优的`[默认循环]`中，这三个模板作为“前置守卫”，在执行主要的角色输出逻辑前，进行一些必要的检查，如：角色是否识别？是否需要换锁定目标？是否需要立即换人？

7.  **`速切模板-全角色` (主干 - 角色分派器)**
    -   **用意**: 当所有前置检查和高优事件都未触发时，由它接管主循环。它的唯一职责是判断当前站场角色，并将控制权交给该角色的专属“大脑”（如 `速切模板-安比`）。

---
**总结**

整个“全配队通用”脚本，就像一个由**“事件调度总监”** (`全配队通用.yml`)领导的**“专家团队”**（各种通用和角色状态模板）。总监根据情况的紧急程度，将任务派给最合适的专家，而专家则调用标准化的动作（操作模板）来完成任务。这使得整个系统分工明确，维护和扩展都非常方便。

## 6.3 实践：如何新增一个角色 (最终深度修正版)

得益于“全配队通用”的解耦设计，为脚本新增一个角色变得非常简单。我们不需要改动顶层战略，只需要像添加插件一样，完成几个步骤。

下面，我们以新增角色“比利”为例，展示一个包含**团队协作逻辑**的完整流程：

---
**第1步: 创建角色的“动作” (操作模板)**

首先，为“比利”定义他所有的基础连招。

-   **位置**: `config/auto_battle_operation/`
-   **操作**: 创建 `比利-普通攻击.yml`, `比利-上Buff动作.yml`, `比利-终结技.yml` 等文件。
-   **用意**: 将角色的所有动作“原子化”，使其成为可被“大脑”调用的独立单元。

---
**第2步: 创建角色的“大脑” (角色专属状态模板)**

接下来，创建“比利”的决策逻辑，并让他学会**“在完成自己的任务后，主动告知系统可以换人”**。

-   **位置**: `config/auto_battle_state_handler/`
-   **操作**: 创建 `速切模板-比利.yml`。

**文件内容示例 (`速切模板-比利.yml`):**
```yaml
handlers:
  - states: "[前台-比利]"
    debug_name: "比利决策树"
    sub_handlers:
      # ... (高优先级任务) ...

      # 常规输出，并在结束后发出“可换人”信号
      - states: ""
        operations:
          - operation_template: "比利-普通攻击" # 打一套输出
          - op_name: "设置状态"               # 【关键】打完后，设置“速切结束”状态
            state: "自定义-合轴时间"
```
**用意**: 在比利完成一套连招后，设置 `自定义-合轴时间` 状态。这个状态就像是比利在举手说：**“我的任务完成了，现在可以考虑紧急换人补状态了。”** 这个信号会被顶层的`[连招结束事件]`场景捕获。

---
**第3步: 将角色“注册”到分派器**

现在，我们需要告诉“交通警察”（角色分派器）现在多了一个“比利”可以调度。

-   **位置**: `config/auto_battle_state_handler/速切模板-全角色.yml`
-   **操作**: 在该文件的 `handlers` 列表中增加一行对“比利大脑”的引用。

**修改示例:**
```yaml
# 在 速切模板-全角色.yml
handlers:
  - state_template: "速切模板-比利"  # <--- 新增此行
  - ...
```
**用意**: 这是将比利接入**常规输出循环**的入口。

---
**第4步: 融入团队轮换 (修改通用轮换模板)**

最后，我们要定义比利在后台时，应在**何种时机**被换上场。这部分逻辑被分散在两个不同目的的“专家模板”中：

**4a. 定义“合轴轮换”：为了补增益而上场**

当一名队友发出 `自定义-合轴时间` 信号后，`priority: 80` 的“合轴”场景会触发。它会调用 `轮换-合轴-全角色.yml`，来决定是否要进行一次**有计划的、以补充团队增益为目的**的换人。

-   **操作**: 修改 `auto_battle_state_handler/轮换-合轴-全角色.yml`。
-   **修改示例**:
    ```yaml
    # 在 轮换-合轴-全角色.yml
    handlers:
      # ... 其他角色的逻辑 ...
      # 新增比利的合轴规则
      - states: "![前台-比利] & [比利-冷却,0,0] & [比利-增益即将消失, -5, 0]"
        debug_name: "合轴切换比利补增益"
        operations:
          - op_name: "按键-切换角色"
            agent_name: "比利"
    ```
-   **用意**: 此处的逻辑是为了**维持战术循环**。

**4b. 定义“紧急轮换”：抓住特殊时机上场**

在 `priority: 9` 的主循环中，每次执行角色动作**之前**，都会调用 `轮换-紧急-全角色.yml` 模板。它用于处理那些**计划之外的、突发的、需要立即换人**的紧急情况。

-   **操作**: 修改 `auto_battle_state_handler/轮换-紧急-全角色.yml`。
-   **修改示例**:
    ```yaml
    # 在 轮换-紧急-全角色.yml
    handlers:
      # ... 其他角色的紧急上场逻辑 ...
      # 新增比利的紧急上场规则
      - states: "![前台-比利] & [敌人-火属性弱点] & [比利-在队]"
        debug_name: "紧急切换比利打弱点"
        operations:
          - op_name: "按键-切换角色"
            agent_name: "比利"
    ```
-   **用意**: 此处的逻辑是为了**抓住战术机会**，它独立于常规的“合轴”轮换。
